Есть текст программы ( массив char ), на текущий символ указывает переменная prog
*********************************************************************
get_token()
*********************************************************************
get_token() считывает следующую лексему и переводит указатель prog на начало следующей лексемы.
пишет результат в глобальные переменные:
 char* token ( текст прочитанного токена )
 char tok ( внутреннее представление токена - число. 0, если нет внутреннего представления )
 char token_type ( тип токена, число )

get_token во всём работает аналогично get_token из Small Basic, кроме:
* пропускает не только табуляции и пробелы, но и переходы на следующую строку.
* возвращает пустую строку в случаях: token_type = ERROR, FINISHED




ТИПЫ ТОКЕНОВ TOKEN_TYPE

DELIMITER  . , ; : ( ) [ ] 
RESERVED const var integer real array of true false
OPERATOR if then else while for to downto do repeat until := readln writeln read write begin end
OPERATION + - * / div mod < > >= <= <> = and or not //для операций не будем вводить внутреннее представление.
FUNCTION exp, ln, sin, cos
VARIABLE идентификаторы ( имена ) переменных
CONSTANT идентификаторы констант

REAL_NUMBER 123.09
INT_NUMBER 123

STRING строки.

FINISHED конец кода программы token = 0
ERROR 134abc 123.abc, неизвестный идентификатор token = 0

____________________
Внутреннее представление лексем ( tok ):
0 - нет представления 

#define WRITELN 10
#define WRITE 11

#define READLN 20
#define READ 21

#define IF 30
#define THEN 31
#define ELSE 32

#define FOR 40
#define TO 41
#define DOWNTO 42
#define DO 43

#define WHILE 44

#define REPEAT 45
#define UNTIL 46

#define BEGIN 50
#define END 51

#define ASSIGNMENT 70 //присваивание :=

#define INTEGER 100 //C int
#define REAL 101 // C float
#define ARRAY 102
#define OF 103


#define CONST 1
#define VAR 2

#define EXP 60
#define LN 61
#define SIN 62
#define COS 63

#define TRUE 1
#define FALSE -1 // 0 нельзя, ибо 0 - нет представления. !!! это паскалевский FALSE, к коду С не имеет отношения.


/////////////////. Заметки о get_token /////////////////

NB! Как только get_token вернула тип токена ERROR, её дальнейшая корректная работа не гарантируется! Она ведёт себя после ошибки по-разному, но в целом она больше не работает как надо.
Например:
Как вы все помните, идентификатор - это некоторое имя, заданное пользователем. В Паскале идентификаторы строятся по таким правилам:
1) первый символ - латинская буква или '_'
2) остальные символы - сколько угодно латинских букв, цифр, знаков '_'.

При разборе "идентификатора" abc&ef по достижении символа & станет ясно, что сей символ не может содержаться в имени идентификатора. get_token упадёт с ошибкой ( token_type = ERROR )  и сообщением "Uncorrect identifier name". При последующем вызове она начнёт разбор с того места, где остановилась. То есть с '&'. Но это вообще невесть что и она упадёт с ошибкой: "Expected latin symbol. Maybe given lexem with cyrillic symbols". И снова не сдвинется дальше ни на байт. При последующем вызове она снова упадёт с этой же ошибкой. И так до безконечности.

Пример2:
А вот при разборе некорректных чисел ( 123abc 123.abc 123.456abc ) после возврата ошибки при последующем вызове get_token прочитает неразобранный на прошлом вызове хвост 'abc' как вполне приемлемое имя идентификатора. Но смысла в этом нет, не так ли?

ИТАК:
Посему прошу вас проверять, не вернула ли get_token ERROR. Если это так, то надо завершать работу интерпретатора ( то есть сигнализировать об ошибке тому, кто вызывал Вашу функцию ).


NB! На данный момент по крайне мере под linux get_token не способна корректно выполнять операции сравнения над кириллическими символами. Однако это не мешает ей проглатывать их внутри строк ( STRING ). Посему имена переменных не могут быть кириллическими в нашей реализации, а вот Паскалевские строчки могут содержать кириллицу.




****************************************************
Работа с переменными
****************************************************
У нас есть 2 простых типа переменных: integer и real
Сложный тип переменных -  array [ ... ]of <простой тип> ( одномерные и двумерные )

Описание переменной хранится в структуре типа variable


Добавление переменной простого типа ( integer или real ) в список известных:
bool addSimpleVariable( char* name, char type )
true - добавление успешное.
false - добавление не удалось. На экран будет выведено сообщение об ошибке.

char* name - имя переменной ( в коде на Паскале )
char type - внутреннее представление типа переменной ( INTEGER или REAL )

Добавление массива:
bool addArrayVariable( char* name )//предполагается, что prog стоит на ':'.
//При помощи get_token самостоятельно разбирается с размерностью, границами, типом массива. Возвращает true в случае успеха, иначе false.
//После завершения работы указатель prog будет стоять на последней лексеме, связанной с объявлением массива ( то есть вызвать get_token для перехода к следующей лексеме нужно самостоятельно ).

Получение значения переменной происходит в 2 этапа:
1)Получить тип переменной  ( возвращает ARRAY, INTEGER или REAL, 0 в случае ошибки ( такой переменной нет; это имя константы - всё это при помощи serror выводится на экран  ) )
char getVariableType( char* name );
2)Проверив тип переменной, вызвать соответствующую функцию:

Получить переменную типа integer. Возвращет указатель на данные. 0 в случае ошибки.
int* getIntegerVariable( char* name );

Получить переменную типа real. Возвращет указатель на данные. 0 в случае ошибки.
float* getRealVariable( char* name );

NB! Так как возвращаются указатели на данные ( а не копии значений ), они могут использоваться для присваивания переменной значения.

Если тип переменной ARRAY, то

1) Узнаем тип данных, хранящихся в массиве.
char getArrayBaseType( char* name )
возвращает INTEGER или REAL, 0 в случае ошибки.
2) Дальше всё сложно...
Мало того, что массивы бывают одномерные и двумерные... Это ещё пол беды:
Для получения значения по индексу:
int* getIntegerArrayValue( char*name )
//Возвращает указатель на данные, в случае ошибки - 0. Самостоятельно при помощи get_token считывает квадратные скобки, индексы в них и на основании всего этого понимает, какой элемент массива нужно вытаскивать. Самостоятельно разбирается с выходом за границы массива, заданием одного индекса для двумерного массива или двух индексов для одномерного - всё это приводит к ошибке и возврату нулевого указателя.
После окончания работы указатель prog будет стоять на закрывающей квадратной скобке ( ']' ). Это сделано для единообразия, вызовете get_token лишний раз самостоятельно.
float* getRealArrayValue( char* name ). То же самое, но для массивов, базовым типом которых является REAL
NB! Так как возвращаются указатели на данные ( а не копии значений ), они могут использоваться для присваивания переменной значения.

Итак, с пол беды мы справились.
Но что касается оператора присваивания, есть ещё такая беда:
var
	a:array [1..10] of integer;
	b:array [1..10] of integer;
	c:array[1..10, 1..10 ] of integer;
begin
	a[2] := 10; //тривиально реализуется при помощи getIntegerArrayValue
	с[1][1] :=20; //тривиально реалзиуется при помощи getIntegerArrayValue
	b:=a;// это другая половина беды... Нужно в этом случае копировать содержимое массива a в массив b. При этом не падать с ошибкой "не указан индекс".
	c[3] := b;//это ещё четвертинка беды - самая большая беда. Тут надо разбираться, что оказывается массив 'c' есть одномерный массив array [1..10] of integer ( ведь объявление массива 'c' по-честному записывается так: c:array [1..10] of ( array[1..10] of integer ) ), а массив b как раз имеет тип array[1..10] of integer, посему если рассматривать массив 'c' как одномерный, массив b вполне сойдёт за его элемент... Вобщем я ещё не все проблемы рассказал, но уже выше крыши.
end.



//NOT DOCUMENTED
//Просто получить описатель переменной. Возвращет указатель на данные. 0 в случае ошибки.
//variable* findStructVariable( char*name );



*****************************************************
Работа с константами
*****************************************************
Напомним, что в Паскале константы описываются в секции CONST и при их описании тип не указывается ( <Имя> = <Значение> ).

Описание константы хранится в структуре variable ( на самом деле они хранятся вместе с переменными - так легче отслеживать уникальность имени константы ).

Ныне допустимы 2 типа констант: целые числа ( INTEGER ), дроби ( REAL ).

Добавление константы:
addConstant( char* name, char* value )//Тип константы определяется автоматические, основываясь на виде строки value


Получение значения константы происходит в 2 этапа:
1)Получить тип константы  ( возвращает INTEGER или REAL, 0 в случае ошибки )
char getConstantType( char* name );
2)Вызвать соответсвующую типу функцию:

Получить константу типа integer. Возвращет указатель на данные. 0 в случае ошибки.
int* getIntegerConstant( char* name );
Получить константу типа real. Возвращет указатель на данные. 0 в случае ошибки.
float* getRealConstant( char* name );
!!! Не вздумайте использовать возвращённые указатели для того, чтобы во время работы паскалевской программы менять значения констант! Константы есть константы. А указатели возвращаются для единообразия ( а то для переменных будут указатели, для констант - значения - тут и запутаться недолго. Итак, всё- указатели ).


***************************************************
Анализатор выражений.
***************************************************


Расчёт арифметических выражений. В случае ошибки в *ok пишет false, иначе true
int get_exp_as_integer( bool* ok )//Предполагается, что результат выражения - INTEGER. Если на каком-то этапе вычислений станет ясно, что результат REAL, возвращается ошибка. Такое поведение нужно для оператора присваивания ( см. "На заметку" ).
float get_exp_as_real( bool* ok )//Просто посчитать значение выражения, возвращает значение типа float ( это на языке C, а вот на языке паскаля - REAL ).

// здесь это не написано. не читайте : bool get_exp_abstract( variable* result ); в случае ошибки возвращает false. В структуру *result в случае успеха будет скопировано описание переменной, в которой хранится результат.

bool get_logic_exp( bool* ok) //Посчитать значение логического выражения. Возвращает true или false. Не забывайте проверять флаг успешности вычислений *ok!!!


**********************************************************
Обработка ошибок
**********************************************************
Помните функцию serror()? Она выводила сообщения об ошибках... Ныне предлагаю пользоваться такой функцией:
void serror( char* ). То есть Вы просто пишите сообщение об ошибке. Не забывайте сообщать об ошибке в процессе работы тому, кто вызывает вашу процедуру ( то есть ваши функции тоже должны каким-то образом говорить об ошибке. В этом документе где-то возвращается нулевой указатель, где-то false... ).


********************************************************
Антону и Васе
********************************************************
Для разбора секций VAR  и CONST есть процедуры bool ReadVAR(), bool ReadCONST(). Посему вам нужно реализовать только основной цикл работы программы: от begin до end.

Кстати говоря, про основной цикл.
Ваше задание вот какое: Вам нужно разработать функцию ExecOperator(), которая просто выполняет Паскалевский оператор. Основная работа интерпретатора будет заключаться в вызове этой функции в цикле ( ведь программа - это последовательность операторов. Исключение составляют описательные секции VAR и CONST, но с ними думаю разберётесь быстро, используя функции ReadVAR и ReadCONST ). Только учтите, что:
ОПЕРАТОР - ЭТО не просто нечто, оканчивающееся ТОЧКОЙ С ЗАПЯТОЙ, а:
1) writeln(...); readln(...); write(...); read(...); 
2) <переменная> := <выражение>;         ( например "a := 3;" "b[8] := 8 + c;" )
3) if <условие> then оператор1 [ else оператор2 ]; //условный оператор. ДА ДА, это именно ОДИН ОПЕРАТОР, внутри которого сидят другие операторы.
4) for <счётчик>:=<выражение> to <выражение> do оператор; //это тоже ОПЕРАТОР
5) while <логическое выражение> do оператор;
6) repeat оператор1; оператор2; .... until <логическое выражение>;
7) begin оператор1; оператор2; ... end; //составной ОПЕРАТОР

Зачем я это пишу?
А вот зачем.
Кто-то делает условный оператор. Вот он прочитал if <логическое условие> then . Положим, <логическое условие> выполнено. Тогда нужно выполнить ОДИН ОПЕРАТОР, стоящий после then. Но кто знает, что нас ждёт? Ведь ОДИН ОПЕРАТОР - это любой из пунктов 1 - 7. И не надо всем изобретать велосипед и вручную реализовывать мини-интерпретатор для своей задачи. Вы как разработчики общей структуры интерпретатора призваны подарить всем волшебную функцию ExecOperator(), которая выполняет оператор ( на начало которого указывает переменная prog ).
Также просим Вас подарить нам функцию PassOperator(), которая просто пропускает текущий оператор ( не выполняет его ) и переходит к следующему ( это нужно для реализации перехода к ветке else, а ещё для выхода из цикла for и while ).

Только вы в свою очередь тоже не изобретайте велосипед. Если вам попался условный оператор, вы просто вызываете функцию обработки условного оператора, которую пишете не вы. То же самое с любым другим пунктом из 1 - 7 ( 7-й как выяснилось делает Лёша ) .


*******************************************************
На заметку
*******************************************************
Паскаль - язык со строгой типизацией. Посему такая программа работать не будет:
var a:integer
begin
a := 1 + 3.14; // ошибка. Real не может быть преобразован к integer
end.


Функции добавления переменных и констант думаю никому не нужны ( см. замечание "Антону и Васе" ).

Более того, даже функции взятия значения переменных не нужны никому, кроме того, кто реализует оператор присваивания и того, кто творит readln и read. Все остальные пользуются функциями int get_exp_as_integer( bool* ok )
float get_exp_as_real( bool* ok ) bool get_logic_exp( bool* ok) и не думают о работе с переменными.

Итак, всем нужны get_token, serror и функции вычисления значений выражений. Для большинства это всё, что нужно знать наизусть из этого документа.
Тому, кто реализует оператор присваивания, нужно уметь получать значения переменных ( в том числе массивов ). Это отдельный разговор.
Тому, кто реализует readln и read всё-таки придётся поразбираться с тем, как записывать значения в переменные.

