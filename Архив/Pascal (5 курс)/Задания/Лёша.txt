******************** Лёша ***********************************


Подсистема input_output - в заголовочном файле input_output.h



write[( <выражение1>, ... , <выражениеn> ) ]
writeln[( <выражение1>, ... , <выражениеn> ) ]

bool ExecWrite();
без комментариев. Всё описано в общих требованиях к реализации операторов.

bool ExecWriteLn();
то же, что ExecWrite(), только в конце выводится переход на следующую строку.




read[( переменная1, ... , перменнаяn ) ]
readln[( переменная1, ... , перменнаяn  ) ]
!!! переменной в этом случае может быть и массив с индексами. Но как ты увидишь ниже, об этом не надо безпокоиться.

bool ExecRead()
Здесь всё стандартно, кроме одной вещи:
ты один из немногих, кто будет работать с подсистемой variables.

Работа с этой подсистемой есть в ОПИСАНИИ ИНТЕРПРЕТАТОРА.

В общих чертах алгоритм такой:

1)  Узнаем тип переменной.  char getVariableType( char* name );
2) Получим значение переменной:
* Для INTEGER int* getIntegerVariable( char* name );
* Для REAL float* getRealVariable( char* name );

* Для ARRAY:
2.1) узнаем базовый тип массива. char getArrayBaseType( char* name )
2.2) Получим значение по индексу int* getIntegerArrayValue( char*name ) или float* getRealArrayValue( char* name ) - эти функции сами прочитают все квадртаные скобки. Если указано нужное количество индексов, будет возвращён результат. Предполагается, что при вызове getIntegerArrayValue текущей лексемой является имя массива ( то есть prog стоит на открывающей квадратной скобке ). После окончания работы текущей лексемой является последняя закрывающая скобка ']'. 



Как видишь, во всех случаях ты в конце концов получил указатели на данные. Если ты запишешь по адресу из указателя данные, то тем самым ты изменишь значение паскалевской переменной.

bool ExecReadLn() - аналогично.

Разница между ReadLn и  Read : ReadLn считывает значение и переходит к следующей строке, пропуская лишние символы в потоке ввода,
а вот при помощи read можно считать значения, разделённые пробелом, в пределах одной строки.


Думаю, что тебе об особенностях read и readln не надо думать: пользуйся scanf().
Для read что то вроде scanf("%d", )
для readln scanf("%d\n")



!!! Не забывай, что допустимы и вызовы без параметров ( write, readln )


Также реализуй функции пропуска операторов ввода и вывода:
bool PassWrite PassWriteLn PassRead PassReadLn ()





Подсистема compound_operator - выполнение составных операторов.

bool ExecCompoundOperator();


Составной оператор, это:
begin operator1; operator2; ... operatorn[;] end


(* Антон и Вася! Если вы это читаете, вы уже поняли, что основной цикл работы интерпретатора делает за вас Лёша? *)


Не забудь реализовать функцию пропуска составного оператора bool PassCompoundOperator();
___________________________________________________________________________

Подсистема assignment. Заголовочный файл: assignment.h.

переменная := <выражение>
ИЛИ
массив := массив


Так как вы делаете присваивание вместе с Ильёй, решено разбить присваивание на 3 функции.
bool ExecAssignment()
Она удовлетворяет общим требованиям: На момент вызова ExecAssignment() текущей лексемой должна быть первая лексема оператора присваивания - имя переменной, в которую мы записываем ( в случае массивов - имя массива). На момент окончания работы текущей лексемой будет последняя лексема оператора присваивания.

Ты реализуешь присваивание в переменные типа INTEGER и REAL. С массивами работает Илья.

Вот код ExecAssignment:

boll ExecAssignment()
{
	char type = getVariableType( token );
	if ( type == 0 ) // ошибка.
	{
		serror("Error in assignment. Expected identifier of variable.");
		return false;
	}
	else if ( type == ARRAY )
		return ExecAssignmentForArrays();//реализует Илья
	else
		return ExecSimpleAssignment(); // вот эту функцию сделаешь ты.
}//заметь, что в коде мы не перешли на следующую лексему.

В качестве исключения из правил тебе и Илье разрешается поместить неинтерфейсные функции ExecAssignmentForArrays() и ExecSimpleAssignment() в заголовочном файле подсистемы - зачем разводить лишние файлы длинной в несколько десятков строк?


Итак, задание: сделать функцию 
bool ExecSimpleAssignment().
Она подчиняется общим требованиям к реализации операторов и умеет корректно записывать значения в переменные типа INTEGER и REAL.

Не забудь реализовать PassAssignment(). Думаю, что это можно сделать без реализации функций PassSimpleAssignment и PassAssignmentForArrays.
Ты просто делаешь get_token(), пока не встретишь точку с запятой или оператор. Как только это случилось - делаешь putback() - подумай, почему ( а ещё подумай, может я что-то упустил ).




_____________________________________

ИЛЬЕ:
ты реализуешь return ExecAssignmentForArrays(). Она удовлетворяет общим требованиям к реализации операторов и умеет записывать значения не только в элементы массивов, но и присваивать массив массиву.


Подсистема variables тебе даёт некие средства в помощь.
Алгоритм работы такой:
1) Получаем описание переменной, стоящей слева  от оператора присваивания.
bool getArrayElement( int* shift, struct variable* var )
Требует, чтобы текущей лексемой было имя массива. Самостоятельно считывает квадратные скобки с индексами, по окончании работы текущая лексема - последняя закрывающая ']'.
Возвращает true в случае успеха.
В  структуру *var записывает сведения о прочитанном объекте.
В *shift записывается смещение в векторе, хранящем массив, с которого начинаются рассматриваемые данные. Вобщем некая важная информация. Имеет смысл только при *var.type = ARRAY

2) Если *var.type = INTEGER или REAL, то справа от оператора присваивания стоит выражение. Пытаемся посчитать значение выражения и записать его в левую часть.
3) Если же *var.type =  ARRAY, то справа от оператора присваивания стоит не выражение, а тоже какой то массив. Пытаемся получить его описания при помощи getArrayElement()
3.1) у нас есть две структуры variable. Смотрим, эквиваленты ли их типы:
bool HasEqualTypes( struct variable* var1, struct variable* var2 );
возвращает true в случае, если типы переменных *var1 и *var2 совпадают.

3.2) Если типы совпали, то производим запись:

bool CopyArrayElements( struct variable* left, int left_shift, struct variable* right, int right_shift )
Данные из переменной right будут скопированы в переменную left.
left_shift - смещение, полученное при вызове getArrayElement для левой части оператора присваивания.
right_shift - смещение ... для правой части оператора присваивания.


Пример:
пусть есть:
a: array [1..10, 1..10] of integer;
b: array[ 1..10 ] of integer;


a[1][2] := 10 + 3;
Будет вызвана твоя функция ExecAssignmentForArrays(). Делать она должна примерно вот что ( проверку ошибок опускаю ):
struct variable left; int  left_shift;
getArrayElement( &left_shift, &left );//получили описание левой части оператора присваивания.
//left.type = INTEGER в этом примере, то есть a[1][2] - элемент типа integer. Посему справа от := должно быть выражение.
get_token();//попали на :=
int result;
result = get_exp_as_integer( ... )
*(int*)(left.var) = result; //криво-косо, низкоуровнево, но запись результата в переменную.
//вообще конечно для записи в переменную значения можно было бы поиграться с int* getIntegerArrayValue( char*name ), но очень уж она неповоротлива - придётся запоминать адрес начала оператора присваивания...


А вот для примера a[3] := b

struct variable left; int  left_shift;
getArrayElement( &left_shift, &left );
//left.type = ARRAY, ибо a[3] есть array [1..10] of integer -> справа от := стоит имя массива, возможно с индексом.
get_token() ; // попали на :=
get_token(); // попали на имя массива справа от оператора присваивания.
struct variable right; int  right_shift;
getArrayElement( &right_shift, &right );//получили описание массива справа от :=
if (  HasEqualTypes( left, right ) )
{
	CopyArrayElements( left,  left_shift, right, right_shift );
}
else ошибка - несовместимые типы в присваивании.


Вобщем присваивание для массивов может пока подождать.
