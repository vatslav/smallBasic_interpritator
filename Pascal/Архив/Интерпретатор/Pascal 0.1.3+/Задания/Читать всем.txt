Здесь описана общая информация о заданиях.
Задания раскиданы по файлам ( Витя, Антон и Вася и т.д. ).
Но это не значит, что чтобы выполнить своё задание, не нужно читать чужие задания.



************** Подсистемы и их заголовочные файлы ***********************

Давайте введём некую терминологию.
Подсистема - часть интерпретатора, реализующая определённую функциональность.


Интерфейсная функция - функция, предназначенная для взаимодействия с подсистемой извне.

Заголовочный файл подсистемы - файл с расширением .h, который используется для доступа к подсистеме и содержит объявления ТОЛЬКО интерфейсных функций.


Кроме заголовочных файлов подсистем могут существовать и другие заголовочные файлы - модули. Они предназначены для того, чтобы разбить подсистему на несколько файлов.

!!! В этом документе и заданиях описываются только имена заголовчных файлов подсистем и требования к их интерфейсным функциям. Только к этим объектам относятся все требования данного документа. Всё остальное - ваши модули, внутренние ( не интерфейсные )  функции ваших подсистем вы вольны делать  по своему усмотрению ( исключение - реализация оператора присваивания, где Илья и Лёша пишут неинтерфейсные функции, на которые распространяются все требования данного документа ).



В тексте документа мы будем отождествлять подсистему и её заголовчный файл.

На данный момент есть следующие подсистемы

Подсистема глобальных объявлений с заголовочным файлом global_defines.h - все define-ы вынесено в него. В нём содержатся объявления:
* Типов лексем
* Внутренних представлений лексем
* Объявления, нужные для работы с типом bool в языке C.

Подсистема общих переменных и функций:
globals.h - объявления глобальных переменных ( смотри секцию Глобальные переменные ниже ), функция вывода ошибок serror(). Также пока что здесь содержатся массивы и функции,необходимые для работы get_token().

Подсистема работы с лексемами:
get_token.h - функция чтения следующей лексемы  get_token() и "частичного" возврата на одну лексему назад putback(). В состав подсистемы get_token входит модуль string_functions.h.

Будут реализованы:
Подсистема хранения переменных и констант
variables.h

Подсистема вычисления выражений:
expressions.h

Подсистема чтения описательной части паскалевской программы:
description_part.h

Также ВАМИ будут реализованы подсистемы:

if.h - обработка условных операторов
for.h - обработка операторов цикла for.
while.h - обработка операторов цикла while.
repeat.h - обработка операторов цикла repeat.
assignment.h - обработка оператора присваивания.
input_output.h - ввод-вывод
compound_operator.h - составной оператор

operator.h - выполнение операторов языка Паскаль и их пропуск.




И наконец Антон и Вася поставят точку и сделают файл:
main.с - собственно основной цикл работы интерпретатора.



-----------------------------



************* Глобальные переменные ************************************

Опишу только то, что вам нужно.

char * prog - указатель на символ; бежит по тексту паскалевской программы. Смысл: указывает на следующую лексему.

char token[80] - строка, содержащая текст текущей лексемы.
char token_type - число, тип лексемы.
char tok - число, внутреннее представление лексемы.

************** Чем вам всем нужно пользоваться *************************

Из подсистемы globals.h:

Описанными выше глобальными переменными.
void serror( char* message ) - выводит на экран сообщение об ошибке message.
!!! Прошу вас для вывода ошибок пользоваться именно этой функцией, а не printf() и т.д. !

-------------------------------------------
Из подсистемы get_token.h

char get_token() - функция для чтения следующей лексемы. Возвращает тип считанной лексемы. В глобальную переменную token пишет текст лексемы, tok - внутреннее представление лексемы ( 0 в случае отстутствия внутреннего представления ), token_type - тип считанной лексемы.

В случае обнаружения ошибки token_type = ERROR, token = "",  tok = 0.

Указатель prog перемещает на первый символ после считанной лексемы ( обычно это начало следующей лексемы ).


!!! Если get_token() вернула token_type = ERROR, вы должны ПРЕРВАТЬ РАБОТУ ИНТЕРПРЕТАТОРА, ИБО get_token() УЖЕ НЕ БУДЕТ КОРРЕКТНО РАБОТАТЬ.

ПРИМЕР:
Текст программы: "6 +b". prog стоит в начале строки, то есть указывает на '6'.
get_token() -> token = "6", token_type = INT_NUMBER, tok = 0. Указатель prog перемещён на следующий символ после лексемы, то есть на ПРОБЕЛ.
Функция get_token() в качестве своего значения вернула INT_NUMBER ( то есть тип лексемы можно узнать двумя способоами - по значению функции get_token() и по глобальной переменной token_type ).

get_token() -> token = "+", token_type = OPERATION, tok = 0. prog стоит после лексемы "+", то есть на символе 'b'.
---
void putback() - возврат к предыдущей лексеме.
!!! Это не полноценный возврат! Значения переменных token, tok и token_type не изменятся. Лишь указатель prog будет перемещён на начало текущей лексемы.
То есть эта функция лишь позволяет сделать так, чтобы следующий вызов get_token() привёл к повтроному считыванию текущей лексемы. В каком то смысле мы вернулись к предыдущей лексеме - ибо при get_token() снова считаем нынешнюю лексему. Но никакой информации о предыдущей лексеме мы уже не можем узнать...

Пример:
Текст программы: "6 +b". prog стоит в начале строки, то указывает на '6'.
get_token() -> token = "6", token_type = INT_NUMBER, tok = 0. prog указывает на ПРОБЕЛ после символа '6'.

void putback() -> !!! token = "6", token_type = INT_NUMBER, tok = 0.
НО prog снова стоит в начале строки, то есть указывает на символ '6'.

get_token() -> token = "6", token_type = INT_NUMBER, tok = 0. prog указывает на ПРОБЕЛ после символа '6'.

Итак, мы добились того, что get_token дважды считала одно и то же. Это и есть возрат к предыдущей лексеме в нашем случае.


!!! ЗАМЕЧАНИЕ. Не забывайте пожалуйста про внутренне представление (tok) и тип ( token_type ) токенов! В большинстве случаев этой информации вкупе
с token[0] ( первый символ прочитанной лексемы ) ДОСТАТОЧНО, чтобы понять, что это за токен. А главное, это работает БЫСТРЕЕ, чем strcmp ( сравнение строк ).
------------------------------------------
Из подсистемы expression.h

Расчёт арифметических выражений:

Приведённые ниже функции считают значение выражения, первую лексему которого можно получить вызвав get_token(). После завершения своей работы указатель prog указывает на первую лексему после выражения ( то есть текущей лексемой является последняя лексема выражеия ).

int get_exp_as_integer( bool* ok ) - возвращает значение выражения в виде переменной типа int. Если при вычислении выражения окажется, что значение выражения - не INTEGER, функция аварийно завершает работу: возвращает 0, а в переменную *ok пишет false.
Также *ok = false в случае обнаружения ошибки в выражении.

float get_exp_as_real( bool* ok ) - просто считает значения выражения и возвращает в виде переменной типа float.
*ok = false только в одном случае - в случае ошибки в выражении.

ПРИМЕР:
"writeln( 5 * ( 6.7 + 7 ), b )" prog стоит начале списка параметров, то есть на '('. А это значит, что текущая лексема - "writeln", ибо prog всегда стоит после текущей лексемы.

Поступать здесь надо так:


bool ok; float result;

get_token(); // -> token="(", token_type = DELIMETER

result = get_exp_as_real( &ok );
if ( ok ) // выражение вычислено успешно.
{// выражение вычислено успешно.
// ok = true; prog стоит на первом символе после закрывающей скобки, то есть на ПРОБЕЛЕ.
	printf("result is: %f\n", result);
}
else
{	//ok = false; Ошибка при вычислении выражения. Сообщение об ошибке выведет сама get_exp_as_real, посему вам только нужно сообщить об ошибке на вышестоящий уровень, например так:
	return false;//например
// Если кому интересно, где же находится prog, то он находится где-то в районе ошибки в выражении.
}

get_token() ; // -> token = ",", token_type = "DELIMETER", tok = 0


ДОПОЛНЕНИЕ:
Если бы мы в вышестоящем примере вместо get_exp_as_real() вызвали get_exp_as_integer(), то произошла бы ошибка, ибо выражение 5* (6.7 + 7 ) имеет не целочисленный тип ( в силу того, что в нём есть 6.7 ).

ЗАМЕТКА:

Зачем get_exp_as_integer() так странно себя ведёт?
А вот зачем:
Паскаль - язык со строгой типизацией. Посему такая программа работать не будет:
var a:integer
begin
a := 1 + 3.14; // ошибка. Real не может быть преобразован к integer
end.


Расчёт логических выражений:
bool get_logic_exp( bool* ok) //Посчитать значение логического выражения. Возвращает результат вычисления выражения true или false.
В случае ошибки при вычислении выражения *ok = false.

Также есть функции пропуска выражений:
void pass_exp_as_integer( bool* ok )
void pass_exp_as_real ( bool* ok )
void pass_logic_exp( bool* ok )
Работает аналогично своим противоположностям, разве что не возвращают значения выражения.



Из подсистемы operator.h вам понадобятся функции выполнения и пропуска операторов языка Паскаль:
bool ExecOperator() и bool PassOperator(). Их описание смотрите в задании Антона и Васи. То есть во всех местах в синтаксисе вашего оператора, где ожидается исполнение некоего паскалевского оператора, вы вызываете функцию ExecOperator(). Если же  Паскалевский оператор нужно пропустить ( прыжок к ветке else  например ), вызываете PassOperator.
_
Остальные подробности будут описаны в заданиях.

******** Требования к заголовочным файлам подсистем *************

*Они должны называться так, как написано в этом документе
*Они должны содержать ТОЛЬКО интерфейсные функции, описанные в этом документе ( всё остальное выносите в модули ). Исключение составляет подсистема оператора присваивания, в которой кроме двух интерфесных содержится две неинтерфейсных функции


Что касается того, стоит ли в заголовочном файле оставлять лишь объявления интерфейсных функций, а их реализацию выносить в .c файл - тут вы можете поступать как хотите.

******* Требования к интерфейсным функциям ***********************

*Они должны иметь объявление такое же, как описано здесь.
*Они должны вести себя так, как описано здесь.
*Они должны лежать в тех заголовчных файлах, в которых им велено лежать в этом документе( для неинтерфейсных фукнций вы вольны создавать свои модули и располагать их там по вашему усмотрению ).

Перед заголовком интерфейсной функции в заголовочном файле подсистемы , в комментариях Вы пишете:
*Назначение функции.
*смысл передаваемых в неё аргументов
*Требования к положению указателя prog, которые должны быть выполнены для успешного начала работы функции. Иными словами, нужно описать ожидаемую на начало работы функции текущую лексему.
*смысл возвращаемого значения
*Особенности её поведения
*способ сигнализации об ошибке в процессе выполнения функции.

****** Требования к сигнализации об ошибках ***********************

Ваши интерфейсные функции должны сообщать об ошибках в процессе выполнения. Как - будет описано в вашем задании.

Но помните одно правило:
*Если ошибка возникает непосредственно в вашей функции, вы должны при помощи serror() вывести на экран сообщение об ошибке. Если же ошибка возникает в вызываемой вами функции, вы НЕ СООБЩАЕТЕ ОБ ОШИБКЕ ПРИ ПОМОЩИ serror(), ибо это сделает вызванная вами функция.



P.S. В дальнейшем я постараюсь привести имеющийся ныне код моих подсистем в соответствие с приведёнными здесь требованиями.

*************** Кто что делает *****************************
Вам всем придётся пользоваться функциями друг друга, посему надо знать, где что искать.


мы с Таней: подсистемы get_token, variables, expressions, globals, global_defines, description_part.

Витя: подсистемы repeat, while

Алёша: простая часть подсистемы assignment, подсистема input_output, 
подсистема compound_operator.

Илья: подсистема for, сложная часть подсистемы assignment, подсистема if

Антон и Вася: подсистема operator и файл main.c



***************** Ещё раз об операторах ************************
Все ваши задания - реализовать выполнение того или иного оператора языка Паскаль.

Оператор - это НЕ ВСЕГДА нечто, после которого стоит ТОЧКА С ЗАПЯТОЙ ( более того, точку с запятой МЫ НЕ БУДЕМ СЧИТАТЬ частью оператора )

Не думайте, что всякий оператор кончается точкой с запятой!!! Например в составе оператора if 4>b then writlen('!' ) else b:=0; ни оператор writeln('!' ), ни оператор b:=0 не заканчиваются точкой с запятой! Точкой с запятой заканчивается лишь оператор if!!! ( да и то мы не считаем точку с запятой относящейся к самому оператору )

Посему не надейтесь на точку с запятой! Однако же Антон и Вася проверять её наличие в тех местах, где она нужна, должны!


****************** Общие требования к реализации операторов ************
ЭТО ОБЩИЕ ТРЕБОВАНИЯ. Я НЕ БУДУ КАЖДОМУ ИХ КОПИРОВАТЬ В ЕГО ЗАДАНИЕ. ПРОЧИТАЙТЕ И ПОМНИТЕ.

функции имеют вид bool ExecOperatorName(...);
Возвращают true в случае успеха, false в случае ошибки.

Требуют, чтобы текущей лексемой была первая лексема оператора ( для if - "if", для while - "while". Оператор присваивания - не исключение.

После завершения работы текущей лексемой будет последняя лексема оператора ( НИКОГДА не ; - ибо она не является частью оператора.  )

//FIXME а что делать, если в программе стоит подряд несколько лишних точек с запятой? То есть нужно подумать о пустом операторе.
//FIXME Согласно стандарту есть пустой оператор, и он на самом деле пустой, не состоит ни из одного символа ( допустима конструкция if условие then else). Тогда становится понятен смысл нескольких точек с запятой: пустой оператор + ';' несколько раз. Но давайте пока что ради упрощения не лезть в такие дебри. Сделаем так: ExecOperator, неожиданно встретив точку с запятой в качестве первой лексемы оператора, прощёлкивает точки с запятой и останавливается на предпоследней точке с запятой ( то есть текущей лексемой будет предпоследняя точка с запятой ). Точка с запятой в нашем случае и есть некий пустой оператор. Мы останавливаемся на предпоследней точке с запятой, ибо обычно точка с запятой требуется как разделитель между операторами.


Также не забывайте, что кроме функции выполнения оператора вы все должны реализовать их противоположности - функции пропуска оператора. я об этом буду стараться напоминать в заданиях, но имейте это ввиду. Договорённости о её работе такие же, как и для ExecOperatorName().

********************** Язык реализации ******************************************
Думаю, что средства реализации должны быть адекватны поставленной задаче.
Для реализации процедурного языка, каким является Паскаль, глупо пользоваться полиморфизмом, абстрактными классами, переопределением операторов, наследованием... Это всё конечно красиво, но из пушки по воробьям.

Посему мои коды будут написаны на процедурном языке C.
Отсюда такие особенности:
*если я хочу передать аргумент в функцию так, чтобы она могла его изменить, то я передаю указатель на аргумент.
*Также при объявлении переменных типа структура я пишу слово struct:
struct variable a; вместо variable a;

Однако же я не заставляю вас писать на С. Если хотите, пишите на С++. Только не надо применять STL, C++ ввод и вывод из модуля iostream ( пользуйтесь C-вводом выводом: printf и scanf  ). Также вам не понадобится объявлять классы.
****************** Условные обозначения *************************************
я буду в заданиях давать синтаксис операторов.
в квадратных скобках [ ] будут указаны необязательные части ( то есть того, что внутри квадратных скобок,может и не быть в тексте оператора ).
!!! Эти квадратные скобки не фигурируют в тексте оператора!

НАПРИМЕР:
условный оператор может иметь вид:
if <логическое выражение > then оператор1  else оператор2 
ИЛИ
if <логическое выражение > then оператор1
КРАТКО:
if <логическое выражение > then оператор1 [ else оператор2 ]