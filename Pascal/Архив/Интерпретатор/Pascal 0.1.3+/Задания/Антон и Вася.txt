

*************************** Антон и Вася *****************************
Вам задание такое:
Реализовать функцию
bool ExecOperator()
Она тоже удовлетворяет ОБЩИМ ТРЕБОВАНИЯМ К РЕАЛИЗАЦИИ ОПЕРАТОРОВ , кроме одного пункта:
Процитирую этот пункт:
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
[интерфейсные функции реализации операторов при вызове ] Требуют, чтобы текущей лексемой была первая лексема оператора ( для if - "if", для while - "while". 
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
Так вот, для вас это будет не так. Для вас текущей лексемой должна быть не первая лексема оператора, а ПРЕДЫДУЩАЯ перед ней.

И вот ещё что: вы должны уметь обрабатывать ПУСТОЙ ОПЕРАТОР. Пустой оператор примерно соответствует точке с запятой.

Как ловить пустой оператор? Да в общем очень просто.
Давайте на примерах.

Пример1 ( просто почувствуйте, зачем и кому нужны ExecOperator и PassOperator )
if a>b then writeln("!!!") else a:=10;
Указатель prog в начале строки, то есть текущей лексемой является лексема перед if.

Вызвали ExecOperator() она делает что-то вроде:
get_token();
ExecIf();
return true;
-> prog стоит на ';', а текущей лексемой является "10" - последняя лексема оператора if.

А давайте раскроем вызов ExecIf():
get_logic_exp();
//предположим,что условие выполнено
get_token();//текущей лексемой становится "then"
ExecOperator()//рекурсивный вызов вашей функции. По завершении выпонения текущей лексемой будет ')' - то есть последняя лексема выполненного оператора.

get_token();//текущей лексемой становится else
PassOperator();//Пропускаем оператор ветки else. Текущей лексемой станет последняя лексема оператора ветки else, то есть prog указывает на ';'.


Пример2 ( а теперь о пустом операторе ) :

writeln( a );
readln(b);;;;;;
write( b );


prog стотит на 'w'.
ExecOperator() делает примерно такие действия:
    get_token();//переход к первой лексеме оператора
    ExecWriteLn(); // текущей лексемой станет  ')'
get_token();//текущей лексемой стала точка с запятой первой строки
ExecOperator(): //выполняем readln
    get_token();
    ExecReadLn();//текущей лексемой станет ')'
get_token(); // текущей лексемой станет первая точка с запятой второй строки
ExecOperator():
    get_token();// Попали на первую лексему оператора.
    Происходит что-то, и мы оказываемся на предпоследней точке с запятой
get_token(); //оказались на последней ; второй строки
ExecOperator()...
...
Как видите, для выполнения этого фрагмента кода мы 4 раза выполнили итерацию ExecOperator+get_token. На третьем вызове ExecOperator проглотил лишние точки с запятой. Но мы же не хотим этот случай рассматривать отдельно, посему для get_token он оставил одну точку с запятой!

Но это ещё не всё. Специально для Лёши ( составной оператор ) и Вити ( цикл с постусловием ) Вам надо сделать ещё одну хитрость:

Давайте рассмотрим оператор цикла с постусловием:
repeat
 a := a * b;
 writeln(a);
until a > 10;

Текущей лексемой является repeat ( то есть prog стоит на 'a' в левой части присваивания ).Витя будет делать что-то в этом ключе:ExecOperator() - ваша функция сделает примерно вот что:
	get_token();
	ExecAssignment(); //  Текущей лексемой станет  'b'
get_token();//Витя перешёл на ; Теперь он выполнит следующий оператор.
ExecOperator() //после завершения текущей лексемой будет ')'
get_token() //Витя честно перешёл на точку с запятой. Ну, выполним следующий оператор.
ExecOperator() - ваша функция как ни в чём не бывало сделает:
	get_token() - попали на until
	//А вот теперь ВЫ должны понять, что это не очень то оператор. Призываю вас в случае встречи until или end тут же возвращать false ( Ни шагу назад! И ни шагу вперёд! Вернули false, а текущая лексема until или end ).
//Витя проверит, вдруг текущая лексема - until ( на самом деле он проверял это после каждого вызова ExecOperator ) и поймёт, что цикл кончился.

P.S. В стандарте языка Паскаль пустым оператором считается нулевая последовательность байт, посему допустима конструкция if <условие> then else;. Я было решил эту особенность реализовывать, но в итоге передумал. Зачем? Пустой оператор в таком определении никакой практической ценности не имеет, да ещё и усложняет обработку его наличия.

_
Ещё вам нужно реализовать функцию bool PassOperator(). Требования к ней такие же, как к ExecOperator, только она не выполняет оператор, а пропускает. В помощь вам ребята реализуют Pass-функции ( PassIf PassFor и т.д. для пропуска соответсвующих операторов ).





____
Третье задание - основной цикл работы интерпретатора.

Паскалевская программа состоит из двух частей: описательной и исполнительной.
Разделы VAR, CONST - описательные.
Всё от begin до end. - исполнительное.

С описательным разделом всё просто:
есть функции bool ReadVAR() и bool ReadCONST() в подсистеме description_part.

bool ReadVAR():
возвращает true  в случае успешного разбора секции VAR.
Секция VAR может выглядеть так:
VAR
a,b:integer;
c,d,e:array [1..10] of integer;
k,p:array[1..10,1..8] of real;

Точка с запятой после "real" в данном случае ОТНОСИТСЯ К СЕКЦИИ VAR.

Требует: в момент вызова текущей лексемой должна быть "VAR".
После окончания работы: текущей лексемой будет последняя лексема секции VAR ( ТОЧКА С ЗАПЯТОЙ, ибо она относится к секции VAR ).


ReadCONST() работает аналогично.
Раздел const выглядит так:
CONST
ident1 = value1;
.....
identN = valueN;
Точка с запятой в конце обязательна и считается частью секции CONST. После завершения работы ReadCONST, также как и ReadVAR, текущей лексемой устновит последнюю точку с запятой.


Исполнительная часть программы реализуется при помощи ExecOperator().
Не забывайте, что ; не является частью оператора, посему проверять её наличие в нужных местах вы должны сами!

!!! Прошу вас сделать такую вещь: в случае аварийного завершения интерпретатора вы должны вывести строку, в которой случилась ошибка, и указать место в строке, где случилась ошибка ( будем считать, что на это место указывает prog сразу после ошибки ). Сообщение об ошибке выведут без вас в большинстве случаев.

Вот и всё. Загрузка программы из файла, параметры командной строки инерпретатора - это делайте как хотите )))



































